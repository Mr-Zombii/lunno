# list functions for Lunno

let map: fn(fn(T) -> U, list(T)) -> list(U) =
    fn(f, lst) ->
        let rec loop: fn(list(T), list(U)) -> list(U) =
            fn(xs, acc) ->
                if xs == [] then reverse(acc)
                else loop(xs[1:], [f(xs[0])] + acc)
        loop(lst, [])

let rec reverse: fn(list(T)) -> list(T) =
    fn(lst) ->
        let rec loop: fn(list(T)) -> list(T) =
            fn(xs, acc) ->
                if xs == [] then acc
                else loop(xs[1:], [xs[0]] + acc)
        loop(lst, [])

let length: fn(list(T)) -> int =
    fn(lst) ->
        let rec loop: fn(list(T), int) -> int =
            fn(xs, acc) ->
                if xs == [] then acc
                else loop(xs[1:], acc + 1)
        loop(lst, 0)

let head: fn(list(T)) -> T =
    fn(lst) ->
        if lst == [] then 0 # placeholder
        else lst[0]

let tail: fn(list(T)) -> list(T) =
    fn(lst) ->
        if lst == [] then 0 # placeholder
        else lst[1:]

let foldl: fn(fn(U, T) -> U, U, list(T)) -> U =
    fn(f, init, lst) ->
        let rec loop: fn(list(T), U) -> U =
            fn(xs, acc) ->
                if xs == [] then acc
                else loop(xs[1:], f(acc, xs[0]))
        loop(lst, init)

let foldr: fn(fn(T, U) -> U, U, list(T)) -> U =
    fn(f, init, lst) ->
        foldl(
            fn(acc, x) -> f(x, acc),
            init,
            reverse(lst)
        )

let filter: fn(fn(T) -> bool, list(T)) -> list(T) =
    fn(pred, lst) ->
        let rec loop: fn(list(T), list(T)) -> list(T) =
            fn(xs, acc) ->
                if xs == [] then reverse(acc)
                else if pred(xs[0])
                    then loop(xs[1:], [xs[0]] + acc)
                    else loop(xs[1:], acc)
        loop(lst, [])

let append: fn(list(T), list(T)) -> list(T) =
    fn(a, b) ->
        foldr(fn(x, acc) -> [x] + acc, b, a)

let concat: fn(list(list(T))) -> list(T) =
    fn(lst) ->
        foldr(append, [], lst)