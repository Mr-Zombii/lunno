# List Module for Lunno

from option import Option

# Apply a function to every element of a list,
# producing a new list of results.
let map: fn(fn(T) -> U, [T]) -> [U] {
    fn(f, lst) {
        let rec loop: fn([T], [U]) -> [U] {
            fn(xs, acc) {
                if xs == [] then reverse(acc)
                else loop(xs[1:], [f(xs[0])] + acc)
            }
        }
        loop(lst, [])
    }
}

# Reverse a list.
let reverse: fn([T]) -> [T] {
    fn(lst) {
        let rec loop: fn([T], [T]) -> [T] {
            fn(xs, acc) {
                if xs == [] then acc
                else loop(xs[1:], [xs[0]] + acc)
            }
        }
        loop(lst, [])
    }
}

# Compute the number of elements in a list.
let length: fn([T]) -> int {
    fn(lst) {
        let rec loop: fn([T], int) -> int {
            fn(xs, acc) {
                if xs == [] then acc
                else loop(xs[1:], acc + 1)
            }
        }
        loop(lst, 0)
    }
}

# Return the first element of a list.
let head: fn([T]) -> Option[T] {
    fn(lst) {
        if lst == [] then Option.None
        else Option.Some(lst[0])
    }
}

# Return all elements of a list except the first.
let tail: fn([T]) -> Option[[T]] {
    fn(lst) {
        if lst == [] then Option.None
        else Option.Some(lst[1:])
    }
}

# Left fold over a list.
#
# Applies the function from left to right
let foldl: fn(fn(U, T) -> U, U, [T]) -> U {
    fn(f, init, lst) {
        let rec loop: fn([T], U) -> U {
            fn(xs, acc) {
                if xs == [] then acc
                else loop(xs[1:], f(acc, xs[0]))
            }
        }
        loop(lst, init)
    }
}

# Right fold over a list.
#
# Applies the function from right to left
let foldr: fn(fn(T, U) -> U, U, [T]) -> U {
    fn(f, init, lst) {
        foldl(
            fn(acc, x) { f(x, acc) },
            init,
            reverse(lst)
        )
    }
}

# Filter a list using a predicate function.
#
# Keeps only elements for which the predicate returns true.
let filter: fn(fn(T) -> bool, [T]) -> [T] {
    fn(pred, lst) {
        let rec loop: fn([T], [T]) -> [T] {
            fn(xs, acc) {
                if xs == [] then reverse(acc)
                else if pred(xs[0]) then
                    loop(xs[1:], [xs[0]] + acc)
                else
                    loop(xs[1:], acc)
            }
        }
        loop(lst, [])
    }
}

# Append two lists together.
let append: fn([T], [T]) -> [T] {
    fn(a, b) {
        foldr(fn(x, acc) { [x] + acc }, b, a)
    }
}